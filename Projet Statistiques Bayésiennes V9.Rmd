---
title: "Projet Statistiques Bayésiennes : Données Spotify"
author: "Aline GABRIEL, Alimatou TRAORE, Claude MBIMBIKI, Muriel MAJUM and Lyne NENGUEKO"
date: "2024-03-26"
output:
  html_document:
    toc: true
editor_options: 
  markdown: 
    wrap: 72
---

# Packages

```{r}
options(warn = -1)
library(readr)
library(ggplot2)
library(R2jags)
library(runjags)
library(coda)
library(tidyverse)

library(dplyr)
library(rjags)
library(rstanarm) ## régression avec stan

library(corrplot)

```

```{r, include=FALSE}
plot_credible_intervals <- function(fit) {
  # Extract the MCMC samples and the names of the parameters
  samples <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
  params <- names(samples)

  # Calculate the 50% and 95% credible intervals for each parameter
  intervals <- data.frame(param = character(), lower = numeric(), upper = numeric())
  for (param in params) {
    est_mean = mean(samples[[param]])
    est_median = median(samples[[param]])
    ci_50_infCI <- quantile(samples[[param]], probs = 0.25)
    ci_50_supCI <- quantile(samples[[param]], probs = 0.75)
    ci_95_infCI <- quantile(samples[[param]], probs = 0.025)
    ci_95_supCI <- quantile(samples[[param]], probs = 0.975)
    intervals <- rbind(intervals, data.frame(param = param, est_mean = est_mean, est_median = est_median, ci_50_infCI = ci_50_infCI, ci_50_supCI = ci_50_supCI, ci_95_infCI = ci_95_infCI, ci_95_supCI = ci_95_supCI))
  }

  # Create a ggplot object
  p <- ggplot(intervals, aes(y = param)) +
    theme_classic() +
    geom_segment(aes(y = param, yend = param, x = ci_95_infCI, xend = ci_95_supCI),
                 color = "red", size = 0.5) +
    geom_segment(aes(y = param, yend = param, x = ci_50_infCI, xend = ci_50_supCI),
                 color = "red", size = 1.5) +
        geom_point(aes(x = est_mean), size = 3) +
    labs(title = "Posterior credible intervals") + 
    xlab("")  + 
    ylab("")

  # Print the plot
  print(p)
}
```


# Exploration et traitement des variables

```{r}
spotify_preferences <- read_csv("spotify_preferences.csv")
```

```{r}
data<-spotify_preferences
data$label<-as.factor(data$label)
#data$mode<-as.factor(data$mode)
summary(as.data.frame(data))
```


## Histogrammes

```{r}
plots <- lapply(colnames(data)[-c(14,5)], function(i) {
  ggplot(data = data, aes_string(x = i, fill = "label")) +
    geom_histogram(position = "identity", alpha = 0.7) + 
    labs(title = paste("Histogramme de", i, "en fonction des labels"),
         x = i, y = "Fréquence") +
    scale_fill_manual(values = c("blue", "red")) +  # Couleurs des labels
    theme_minimal()
})

#plots
```


```{r}
ggplot(data = data, aes(x = label, fill = label)) +
  geom_bar( position = "identity", alpha = 0.7) +
  labs(title = "Histogramme de time_signature en fonction des labels",
       x = "time_signature", y = "Fréquence") +
  scale_fill_manual(values = c("blue", "red")) +  # Couleurs des labels
  theme_minimal()

```



## Création de vecteurs pour l'étude Bayésienne

```{r}

danceability_like <- data$danceability[data$label == "like"]
danceability_dislike <- data$danceability[data$label == "dislike"]

energy_like <- data$energy[data$label == "like"]
energy_dislike <- data$energy[data$label == "dislike"]

key_like <- data$key[data$label == "like"]
key_dislike <- data$key[data$label == "dislike"]


loudness_like <- data$loudness[data$label == "like"]
loudness_dislike<- data$loudness[data$label == "dislike"]

mode_like <- data$mode[data$label == "like"]
mode_dislike <- data$mode[data$label == "dislike"]

speechiness_like <- data$speechiness[data$label == "like"]
speechiness_dislike <- data$speechiness[data$label == "dislike"]


acousticness_like=data$acousticness[data$label == "like"]
acousticness_dislike=data$acousticness[data$label == "dislike"]

instrumentalness_like=data$instrumentalness[data$label == "like"]
instrumentalness_dislike=data$instrumentalness[data$label == "dislike"]

liveness_like=data$liveness[data$label == "like"]
liveness_dislike=data$liveness[data$label == "dislike"]

valence_like <- data$valence[data$label == "like"]
valence_dislike <- data$valence[data$label == "dislike"]

tempo_like <-  data$tempo[ data$label == "like"]
tempo_dislike <-  data$tempo[ data$label == "dislike"]

duration_like <- data$duration[data$label == "like"]
duration_dislike <- data$duration[data$label == "dislike"]

time_signature_like <- data$time_signature[data$label == "like"]
time_signature_dislike <- data$time_signature[data$label == "dislike"]
```

## Etude de corrélation

```{r}
correlation_matrix <- cor(data[,-c(5,14)])
corrplot(correlation_matrix, method = "circle")
```


# 1- Variable : danceability

**Description :** La variable de dansabilité qui varie de 0 à 1 nous permet de décrire à quel point une piste est adaptée à la danse en fonction d'une combinaison d'éléments musicaux ( tempo, stabilité du rythme, force du rythme et régularité globale). Une valeur de 0.0 est la moins dansable et 1.0 est la plus dansable.

```{r}
ggplot(data, aes(x = danceability, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de danceability en fonction du label",
         x = "danceability",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

### Modèle

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, precision1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, precision2)
  }

  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 3)
  sigma2 ~ dunif(0, 3)
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"
y1 <- danceability_like
y2 <- danceability_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("mu1", "mu2", "sigma1", "sigma2"))

jags_samples
```


### Interprétation

```{r}
plot_credible_intervals(jags_samples)
```


```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1    

hist(mu_diff, main = "Histogramme de mu2 - mu1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)

```

### Etude des mcmc

```{r}
plot(jags_samples)
```


### Fake data check

```{r}
generate_fake_data <- function(n1, n2) {

  mean1_fake <- 0.5
  sd1_fake <- 0.2
  mean2_fake <- 0.7
  sd2_fake <- 0.15

  # Générer des données factices à partir de la distribution normale

  y1_fake <- rnorm(n1, mean1_fake, sd1_fake)
  y2_fake <- rnorm(n2, mean2_fake, sd2_fake)

  return(list(y1_fake = y1_fake, y2_fake = y2_fake))

}

# Générer des données factices à partir des échantillons postérieurs

fake_data <- generate_fake_data(length(danceability_like), length(danceability_dislike))

# Comparer les données factices avec les données réelles

summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))

# Compiling and producing posterior samples from the model.

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("mu1", "mu2", "sigma1", "sigma2"))

# Plotting and summarizing the posterior distribution

jags_samples

plot_credible_intervals(jags_samples)

plot(jags_samples)

summary(jags_samples)

 

```

**Conclusion** : 

# 2- Variable : energy

**Description :** Le choix du prior ici s'est fait de facon arbitraire et aussi en observant nos données. 

```{r}
ggplot(data, aes(x = energy, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de energy en fonction du label",
         x = "energy",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```
 
### Modèle 1 : Gausienne

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, precision1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, precision2)
  }

  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 1)
  sigma2 ~ dunif(0, 1)
   precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"
y1 <- energy_like
y2 <- energy_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("mu1", "mu2", "sigma1", "sigma2"))

jags_samples
```

```{r}
plot_credible_intervals(jags_samples)
```


```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1    

hist(mu_diff, main = "Histogramme de mu2 - mu1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)
```


## Modèle 2 : beta

```{r}

model_string <- "

model {

  # Likelihood for y1

  for (i in 1:n1){

    y1[i] ~ dbeta(alpha1, beta1)

  }

  # Likelihood for y2

  for (i in 1:n2){

    y2[i] ~ dbeta(alpha2, beta2)

  }

  # Priors

  alpha1 ~ dunif(1, 5)
  beta1 ~ dunif(0, 2.5)

  alpha2 ~  dunif(1, 5)
  beta2 ~ dunif(0, 2.5)

}

"

y1 <- energy_like
y2 <- energy_dislike
n1 <- length(y1)
n2 <- length(y2)

data_list <- list(y1 = y1, y2 = y2, n1 = n1, n2 = n2)

# Run JAGS

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("alpha1", "beta1", "alpha2", "beta2"))


jags_samples

```

```{r}

plot_credible_intervals(jags_samples)

```

### Interprétation

```{r}

jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

 

mean_diff <- jags_samples_df$alpha2/(jags_samples_df$alpha2 + jags_samples_df$beta2) - jags_samples_df$alpha1/(jags_samples_df$alpha1 + jags_samples_df$beta1)   
hist(mean_diff, main = "Histogramme de la différence des moyennes", xlab = "Différence entre les moyennes")

mean(mean_diff > 0)

```

## Etude des mcmc

```{r}
plot(jags_samples)
```
### Fake data check

```{r}
generate_fake_data <- function(n1, n2) {
  alpha1_fake <- 1.53
  beta1_fake <- 1.56
  alpha2_fake <- 3.5
  beta2_fake <- 1.25

  # Générer des données factices à partir de la distribution bêta

  y1_fake <- rbeta(n1, alpha1_fake, beta1_fake)

  y2_fake <- rbeta(n2, alpha2_fake, beta2_fake)

 

  return(list(y1_fake = y1_fake, y2_fake = y2_fake))

}


# Générer des données factices à partir des échantillons postérieurs

fake_data <- generate_fake_data(length(energy_like), length(energy_dislike))

# Comparer les données factices avec les données réelles

summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))

# Compiling and producing posterior samples from the model.

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("alpha1", "beta1", "alpha2", "beta2"))
# Plotting and summarizing the posterior distribution
jags_samples

plot_credible_intervals(jags_samples)

summary(jags_samples)

plot(jags_samples)

```




# 3- Variable : key

**Description :** La tonalité de la piste, elle varie parmi les entiers de 0 à 11, qui représentent des
hauteurs à l’aide de la notation standard de la classe de hauteur.


```{r}
ggplot(data, aes(x = key, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de duration en fonction du label",
         x = "duration",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```


### Modèle

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dpois(lambda1)
  }
  for (i in 1:n2){
    y2[i] ~ dpois(lambda2)
  }

  lambda1 ~ dunif(1, 6)
  lambda2 ~ dunif(1, 6)
}
"
y1 <- key_like
y2 <- key_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("lambda1", "lambda2"))

jags_samples
```


```{r}
plot_credible_intervals(jags_samples)
```

### Interprétation

```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$lambda2 - jags_samples_df$lambda1    

hist(mu_diff, main = "Histogramme de lambda2 - lambda1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)
```

### Etude des mcmc

```{r}
plot(jags_samples)
```

### Fake data check
```{r}
generate_fake_data <- function(n1, n2) {

  lambda1_fake <- 4.79# Utiliser la médiane au lieu de la moyenne

  lambda2_fake <- 4.78

  #lambda1_fake <- runif(1, min = 1, max = 6)

  #lambda2_fake <- runif(1, min = 1, max = 6)

  # Générer des données factices à partir de la distribution de Poisson

  y1_fake <- rpois(n1, lambda1_fake)

  y2_fake <- rpois(n2, lambda2_fake)

  return(list(y1_fake = y1_fake, y2_fake = y2_fake))

}

fake_data <- generate_fake_data(length(key_like), length(key_dislike))

summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

 
data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("lambda1", "lambda2"))

jags_samples

plot_credible_intervals(jags_samples)

plot(jags_samples)

summary(jags_samples)

```



# 4- Variable : loudness

**Description :** Les valeurs d'intensité sonore sont moyennées sur
l'ensemble de la piste et sont utiles pour comparer le volume relatif
des pistes.L'intensité sonore est la qualité d'un son qui est la
principale corrélat psychologique de la force physique (amplitude). Les
valeurs varient généralement entre -60 et 0 dB.

```{r}
ggplot(data, aes(x = loudness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de loudness en fonction du label",
         x = "loudness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

## Modèle 

```{r}
model_string_loudness <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, precision1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, precision2)
  }

  mu1 ~ dunif(-40, 0)
  mu2 ~ dunif(-40, 0)
  
  sigma1 ~ dunif(0, 70)
  sigma2 ~ dunif(0, 70)
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

y1 = loudness_like
y2 = loudness_dislike
# Créer une liste de données pour JAGS
data_list <- list(y1 = y1, y2 = y2 ,n1 = length(y1), n2 = length(y2))

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Visualiser les résultats
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
# The probability that the rate theta1 is smaller than theta2
mean(s$mu2 < s$mu1)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$mu2 - s$mu1)
```

**Remarque** : Avec l'histogramme ci-contre et après calcul de la
probabilité on peut donc constater que l'instructeur préfère les
musiques pas très bruyantes.

## MCMC

```{r}
plot(jags_samples)
```

## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  mu1_fake <- -20  # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- -15
  
  sigma1_fake <- 30
  sigma2_fake <- 40
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1,mu1_fake, sigma1_fake)
  y2_fake <- rnorm(n2,mu2_fake, sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(loudness_like),length(loudness_dislike))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake),n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion** : Le modèle choisi est bien confirmé.

# 5- Variable : mode

**Description :** Mode indique la modalité (majeure ou mineure) d'un
piste, le type de gamme à partir de laquelle son contenu mélodique est
dérivé. Le majeur est représenté par 1 et le mineur par 0.

```{r}
ggplot(data, aes(x = mode, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de mode en fonction du label",
         x = "mode",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

## Modèle

```{r}
model_string_mode <- "
model {
  theta1 ~ dbeta(1, 1)
  theta2 ~ dbeta(1, 1)
  
  for (i in 1:n1){
    y1[i] ~ dbern(theta1)
  }
  for (i in 1:n2){
    y2[i] ~ dbern(theta2)
  }
}
"

y1 = as.double(mode_like)
y2 = as.double(mode_dislike)

data_list <- list(y1 = y1, y2 = y2, n1=length(y1),n2=length(y2))

jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1","theta2"))
```

```{r}
plot_credible_intervals(jags_samples)
```


## Interprétation

## Etude des mcmc

```{r}
plot(jags_samples)
```


## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  theta1_fake <- 0.74  # Utiliser la médiane au lieu de la moyenne
  theta2_fake <- 0.5
  
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rbernoulli(n1,theta1_fake)
  y2_fake <- rbernoulli(n2,theta2_fake)
  
  return(list(y1_fake = as.double(y1_fake), y2_fake =as.double(y2_fake)))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(mode_like),length(mode_dislike))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1=length(y1),n2=length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1", "theta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion :** Avec le plot suivant, les données fausses confirment bien notres modèle

# 6- Variable : speechiness

**Description :** Speechiness détecte la présence de mots prononcés dans
une piste.les valeurs supérieures à 0,66 décrivent des morceaux qui sont
probablement entièrement constitués de paroles mots. Les valeurs
comprises entre 0,33 et 0,66 décrivent des pistes qui peut contenir à la
fois de la musique et de la parole, soit en sections, soit en couches, y
compris des cas tels que la musique rap. Valeurs ci-dessous 0,33
représente très probablement la musique et d'autres éléments non vocaux.

```{r}
ggplot(data, aes(x = speechiness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de speechiness en fonction du label",
         x = "speechiness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

## Modèle

```{r}
# Spécifier le modèle JAGS
model_string_speechiness <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dgamma(alpha1,beta1)
  }
  for (i in 1:n2){
    y2[i] ~ dgamma(alpha2,beta2)
  }

  alpha1 ~ dgamma(2,0.8)
  alpha2 ~ dgamma(2,0.8)
  
  beta1 ~ dgamma(2,0.8)
  beta2 ~ dgamma(2,0.8)
}
"
y1=speechiness_like
y2=speechiness_dislike
  
# Créer une liste de données pour JAGS
data_list <- list(y1 = y1, y2 = y2,n1 = length(y1), n2 = length(y2) )

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "alpha2","beta1","beta2"))

# Visualiser les résultats
plot_credible_intervals(jags_samples)

```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

# The probability that the rate theta1 is smaller than theta2
mean(s$beta1 < s$beta2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$beta2 - s$beta1)
# The probability that the rate theta1 is smaller than theta2
mean(s$alpha1 < s$alpha2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$alpha2 - s$alpha1)
```

**Remarque :** L'intructeur préfère les musiques avec le plus de paroles
(les plus chantées)


## Etude des mcmc

```{r}
plot(jags_samples)
```

## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  alpha1_fake <- 2  # Utiliser la médiane au lieu de la moyenne
  alpha2_fake <- 1.5
  
  beta1_fake <- 10
  beta2_fake <- 40
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rgamma(n1,alpha1_fake, beta1_fake)
  y2_fake <- rgamma(n2,alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(speechiness_like),length(speechiness_dislike))

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(y1), n2 = length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "alpha2","beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion :** Le beta2 trouvé par le modèle ne correspond tout a fait à celui considéré au départ lors de la simulation. Ce qui remet en cause l'exactitude du modèle.

# 7- Variable : acousticness

**description** A confidence measure from 0.0 to 1.0 of whether the
track is acoustic. 1.0 represents high confidence the track is acoustic.

En observant les datas, je suppose que l'accousticness des disliked
suivent une beta, la distribution des likes comme cuvette applatie fit
avec une loi beta où $\alpha=\beta\le 1$.

```{r}
ggplot(data, aes(x = acousticness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de acousticness en fonction du label",
         x = "acousticness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(data, aes(x = acousticness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    #stat_function(fun = beta_density, args = list(alpha = 0.7, beta = 0.7), color = "black") +
    labs(title = "Histogramme des valeurs en fonction du label",
         x = "Acousticness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label

```

## Modèle

```{r}
model_string_acc <- "
model {
  alpha1 ~ dunif(0,2);
  alpha2 ~ dunif(0,2);
  beta1 ~ dunif(0,2);
  beta2 ~ dunif(0,2);
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"


data_list_acc <- list(y1 = acousticness_like, y2 = acousticness_dislike,
                  n1 = length(y1), n2 = length(y2))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list_acc, monitor = c("alpha1","alpha2", "beta1","beta2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```

## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```

## Fake data check

```{r}
generate_fake_data_beta <- function(n1, n2,alpha1_fake,alpha2_fake,beta1_fake,beta2_fake) {

  y1_fake <- rbeta(n1, alpha1_fake, beta1_fake)
  y2_fake <- rbeta(n1, alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}
```


```{r}
alpha_1=0.5
alpha_2=0.9
  
beta_1=0.5
beta_2=0.7


fake_data <- generate_fake_data_beta(length(acousticness_like), length(acousticness_dislike),alpha_1,alpha_2,beta_1,beta_2)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(acousticness_like)
summary(acousticness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```
```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```


**Conclusion** : 


# 8- Variable : instrumentalness

**description** Predicts whether a track contains no vocals. "Ooh" and
"aah" sounds are treated as instrumental in this context. Rap or spoken
word tracks are clearly "vocal". The closer the instrumentalness value
is to 1.0, the greater likelihood the track contains no vocal content.
Values above 0.5 are intended to represent instrumental tracks, but
confidence is higher as the value approaches 1.0.
```{r}
ggplot(data, aes(x = instrumentalness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de instrumentalness en fonction du label",
         x = "instrumentalness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

```{r}
gamma_density <- function(x, alpha, beta) {
  dgamma(x, shape = alpha, rate = beta)
}

ggplot(data, aes(x = instrumentalness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  stat_function(fun = beta_density, args = list(0.3,2.5), color = "red") +# Add gamma density curve
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Instrumentalness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```

En observant les données on va partir sur une distribution de poisson
pour les deux variables.

## Modèle

```{r}
model_string_instr <- "
model {

  for (i in 1:n1){
    y1[i] ~ dbeta(alpha1,beta1)
  }
  for (i in 1:n2){
    y2[i] ~ dbeta(alpha2,beta2)
  }
  alpha1 ~ dunif(0,5);
  alpha2 ~ dunif(0,5);
  beta1 ~ dunif(0,10);
  beta2 ~ dunif(0,10);
}
"


y1 = instrumentalness_like+0.01
y2 = instrumentalness_dislike+0.01
data_list_instr <- list(y1 = y1, y2 = y2,n1 = length(y1), n2 =length(y2))
```


```{r}
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list_instr, monitor = c("alpha1","alpha2","beta1","beta2"))

```



```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```
## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```

## Fake data check


```{r}
alpha_1=0.35
alpha_2=0.9
  
beta_1=4
beta_2=8

fake_data <- generate_fake_data_beta(length(instrumentalness_like), length(instrumentalness_dislike),alpha_1,alpha_2,beta_1,beta_2)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(instrumentalness_like)
summary(instrumentalness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)
```




**Conclusion** : 

# 9- Variable : liveness

**description**Detects the presence of an audience in the
recording. Higher liveness values represent an increased
probability that the track was performed live. A value above
0.8 provides strong likelihood that the track is live.
```{r}
ggplot(data, aes(x = liveness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de liveness en fonction du label",
         x = "liveness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(data, aes(x = liveness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  #stat_function(fun = beta_density, args = list(alpha = 2.5, beta = 15), color = "black") +  # Add gamma density curve
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Liveness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```
Observation, on en déduit une loi beta

## Modèle

```{r}

model_string_liv <- "
model {
  alpha1 ~ dunif(0,3);
  alpha2 ~ dunif(0,3);
  beta1 ~ dunif(0,10);
  beta2 ~ dunif(0,10);
  
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"


data_list_liv <- list(y1 = liveness_like,  y2 = liveness_dislike, 
                  n1 = length(liveness_like), n2 = length(liveness_dislike))
```
```{r}
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list_liv, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```


## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```

## Fake data check



```{r}
#Liveness##

alpha_1=2.5
alpha_2=1.2
  
beta_1=2
beta_2=9

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data_beta(length(liveness_like), length(liveness_dislike),alpha_1,alpha_2,beta_1,beta_2)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(liveness_like)
summary(liveness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
```


```{r}
plot_credible_intervals(jags02_samples)
summary(jags_samples)
```

**Conclusion** : 

# 10- Variable : valence

**Description :**  Elle décrit la positivité musicale véhiculée par une piste et varie  entre de 0 et 1  .

```{r}
ggplot(data, aes(x = valence, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de valence en fonction du label",
         x = "valence",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```
## Modèles

```{r message=FALSE, warning=FALSE}
model_string_valence <- "
model {
  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 1)
  sigma2 ~ dunif(0, 1)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- valence_like
y2 <- valence_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_valence, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
jags_samples
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mean(jags_samples_df$mu1 < jags_samples_df$mu2)

hist(jags_samples_df$mu1 - jags_samples_df$mu2)
```

## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```

## Fake data check

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 0.5  # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 0.5
  
  sigma1_fake<-0.1
  sigma2_fake<-0.1
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(valence_like), length(valence_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_valence, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Plotting and summarizing the posterior distribution
plot_credible_intervals(jags_samples)
summary(jags_samples)
```

**Conclusion** : Les  resulats suggerent qu’en moyenne, les chansons appréciées par l’instructeur  présentent une valence plus faible par rapport aux chansons non appréciées.

## Interprétation

# 11- Variable : tempo

**Description :**  Représente le tempo global estimé d’une piste en battements par minute (BPM). Dans
la terminologie musicale, le tempo est la vitesse ou le rythme d’un morceau donné .

```{r}
ggplot(data, aes(x = tempo, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de tempo en fonction du label",
         x = "tempo",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```

## Modèle

```{r message=FALSE, warning=FALSE}


model_string_tempo <- "
model {
  mu1 ~ dunif(0, 2000)
  mu2 ~ dunif(0, 2000)
  sigma1 ~ dunif(0, 1000)
  sigma2 ~ dunif(0, 1000)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- tempo_like
y2 <- tempo_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_tempo, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
head(s)
 # The probability that the rate theta1 is smaller than theta2
mean(s$mu1 < s$mu2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$mu1 - s$mu2)
```

## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```


## Fake data

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 100 # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 129
  
  sigma1_fake<-20
  sigma2_fake<-10
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(valence_like), length(valence_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_tempo, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

**Conclusion** : Les intervalles crédibles postérieurs suggèrent que le tempo moyen des chansons aimées et non aimées ne présente pas de différences significatives notable .

# 12- Variable : duration

**Description :** Cette variable est la durée de la musique en millisecondes.

```{r}
ggplot(data, aes(x = duration, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de duration en fonction du label",
         x = "duration",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```


## Modèles

```{r}
model_string_duration <- "
model {
  mu1 ~ dunif(180000, 240000)
  mu2 ~ dunif(180000, 240000)
  sigma1 ~ dunif(0, 100000)
  sigma2 ~ dunif(0, 100000)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- duration_like
y2 <- duration_dislike
data_list_duration <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_duration, data = data_list_duration, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
# Conversion des échantillons JAGS en un data frame
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

# Calcul de la différence entre mu2 et mu1
mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1



# Tracé de l'histogramme
hist(mu_diff)

```

```{r}
mean(mu_diff < 0)
```

## Etude des mcmc

```{r}
# Vérification de la convergence de l'algorithme MCMC
print(jags_samples)

# Tracer les diagnostics de convergence
plot(jags_samples)
```

```{r}

# Trace plots
plot(jags_samples)

# Gelman-Rubin statistic
gelman.diag(jags_samples)

# Autocorrelation plots
autocorr.plot(jags_samples)

# Effective sample size
effectiveSize(jags_samples)

```

## Fake data check

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 200000 # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 230000
  
  sigma1_fake<-40000
  sigma2_fake<-60000
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(duration_like), length(duration_dislike))


data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_duration, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
plot_credible_intervals(jags_samples)
```


**Conclusion** : Ces résultats suggèrent que l’instructeur préfères les musiques plus longues, c’est à
dire que μ2 < μ1.


# 13- Variable : time_signature

```{r}
ggplot(data, aes(x = time_signature, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de time_signature en fonction du label",
         x = "time_signature",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```


**Description :** Cette variable décrit la signatures rythmiques, le nombre de temps dans chaque mesure.


## Modèle

```{r}
model_string_time_signature_like <- "
model {
  lambda1 ~ dgamma(4*12, 12)
  lambda2 ~ dgamma(4*12, 12)
  
  
  for (i in 1:n1) {
    y1[i] ~ dpois(lambda1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dpois(lambda2)
  }
}
"


# Définition des données
y1 <- time_signature_like
y2 <- time_signature_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_time_signature_like, data = data_list, monitor = c("lambda1", "lambda2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
# Conversion des échantillons JAGS en un data frame
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

# Calcul de la différence entre mu2 et mu1
lambda_diff <- jags_samples_df$lambda2 - jags_samples_df$lambda1

# Tracé de l'histogramme
hist(lambda_diff)

mean(lambda_diff > 0)
```

## Etude des mcmc

```{r}
library(coda)

plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)

effectiveSize(jags_samples)
```

## Fake data check

```{r}
generate_fake_data <- function(n1, n2) {
  lambda1_fake <- 4  
  lambda2_fake <- 3.5
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rpois(n1, lambda1_fake)
  y2_fake <- rpois(n2, lambda2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(time_signature_like), length(time_signature_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_time_signature_like, data = data_list, monitor = c("lambda1", "lambda2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)
```

**Conclusion ** Ces résultats suggèrent que en moyenne les musiques que l’instructeur aime sont à
3.84 temps, c’est à dire entre 3 et 4 temps et d’autre part les musiques qu’il n’aime pas
sont en moyenne à 4 temps. Il semble y avoir une différence entre les deux distributions
estimées, mais cela ne constitue pas une preuve absolue.


# Regression stan_glm

Voici la liste des variables avec lesquelles nous pouvons travailler pour la régréssion multivariée.
```{r}
colnames(data)
```
Nous allons commencer par étudier la corrélation de ces variables. 

```{r}
library(corrplot)
cor_variables=cor(data[,colnames(data)!="label"])
corrplot(cor_variables)
```
Pour la régression multivariée, il est nécéssaire de travailler avec des variables indépendantes. Pour cette raison, pour la régréssion nous allons uniquement considerer les variables suivantes: key, speechiness, instrumentalness, liveness, tempo,duration, time_signature

```{r}
library(corrplot)
cor_variables=cor(data[,c("key", "speechiness", "instrumentalness", "liveness", "tempo", "duration", "time_signature","mode")])
corrplot(cor_variables)
```



```{r}
set.seed(123)

# Créer une variable binaire (0 ou 1)
label <- spotify_preferences$label
label <- ifelse(spotify_preferences$label == "like", 1, 0)

# Spécifier le modèle de régression logistique
model <- stan_glm(label ~ key + speechiness+ instrumentalness + liveness + tempo+duration + time_signature + mode, family = binomial(), data = data)

# Résumé du modèle
summary(model)

# Afficher les diagnostics

plot(model)

```

*Conclusion* Parmis les variables indépendantes, celle qui a le plus d'influence sur l'avis de l'auditeur est la variable speechiness. Celles qui vienne après ayant un coefficient visiblement non nul mais toujours faible est time_signature et liveness. 

# Prédiction

```{r}
# Charger la librairie nécessaire
#library(caret)

# Faire des prédictions sur les données d'entraînement
predictions <- predict(model, type = "response")

# Seuiller les prédictions à 0 ou 1
threshold <- 0.5
predictions_binary <- ifelse(predictions > threshold, 1, 0)

# Convertir en un vecteur de 0 et 1
datalabel_binary <- ifelse(data$label == "like", 1, 0)

# Calculer l'exactitude
accuracy <- mean(predictions_binary == datalabel_binary)
accuracy
```

Stevie Wonder	At The Close Of A Century	I Just Called To Say I Love You



```{r}
X_new=data.frame(danceability=0.748,energy=0.551,key=1,loudness=-9.054,mode=1,speechiness=0.0239, acousticness=0.243, instrumentalness=1.57e-06, liveness=0.0943, valence= 0.65, tempo=113.535, duration =262240 ,time_signature=4)
```

Ed Sheeran	÷ (Deluxe)	Perfect

```{r}
X_new=data.frame(danceability=0.599,energy=0.448,key=8,loudness=-6.312,mode=1,speechiness=0.0232, acousticness=0.163, instrumentalness=0.0, liveness=0.106, valence= 0.168, tempo=95.05, duration =263400 ,time_signature=3)
# Faire des prédictions sur de nouvelles données
predictions <- predict(model, newdata = X_new, type = "response")

threshold <- 0.5
predictions_ <- ifelse(predictions > threshold, "like", "dislike")
predictions_
```

