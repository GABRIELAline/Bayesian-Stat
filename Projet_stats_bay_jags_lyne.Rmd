---
title: "Projet statistique bayésienne"
author: "Lyne nengueko"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Charger la librairie
library(runjags)
library(tidyverse)
library(rjags)
library(coda)
```

```{r, include=FALSE}
plot_credible_intervals <- function(fit) {
  # Extract the MCMC samples and the names of the parameters
  samples <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
  params <- names(samples)

  # Calculate the 50% and 95% credible intervals for each parameter
  intervals <- data.frame(param = character(), lower = numeric(), upper = numeric())
  for (param in params) {
    est_mean = mean(samples[[param]])
    est_median = median(samples[[param]])
    ci_50_infCI <- quantile(samples[[param]], probs = 0.25)
    ci_50_supCI <- quantile(samples[[param]], probs = 0.75)
    ci_95_infCI <- quantile(samples[[param]], probs = 0.025)
    ci_95_supCI <- quantile(samples[[param]], probs = 0.975)
    intervals <- rbind(intervals, data.frame(param = param, est_mean = est_mean, est_median = est_median, ci_50_infCI = ci_50_infCI, ci_50_supCI = ci_50_supCI, ci_95_infCI = ci_95_infCI, ci_95_supCI = ci_95_supCI))
  }

  # Create a ggplot object
  p <- ggplot(intervals, aes(y = param)) +
    theme_classic() +
    geom_segment(aes(y = param, yend = param, x = ci_95_infCI, xend = ci_95_supCI),
                 color = "red", size = 0.5) +
    geom_segment(aes(y = param, yend = param, x = ci_50_infCI, xend = ci_50_supCI),
                 color = "red", size = 1.5) +
        geom_point(aes(x = est_mean), size = 3) +
    labs(title = "Posterior credible intervals") + 
    xlab("")  + 
    ylab("")

  # Print the plot
  print(p)
}
```

## I- Importation de la Dataset

```{r}
data <- read.csv("spotify_preferences.csv")
```

```{r}
#data$mode <- as.factor(data$mode)
#summary (data)
```


```{r}
data$label <- as.factor(data$label)

```


```{r}
loudness_like <- data$loudness[data$label == "like"][1:100]
loudness_dislike<- data$loudness[data$label == "dislike"][1:100]

mode_like <- data$mode[data$label == "like"][1:100]
mode_dislike <- data$mode[data$label == "dislike"][1:100]

speechiness_like <- data$speechiness[data$label == "like"][1:100]
speechiness_dislike <- data$speechiness[data$label == "dislike"][1:100]
```


## II- Exploration et traitement des variables

### 1- Variable loudness

**Description :** Les valeurs d'intensité sonore sont moyennées sur l'ensemble de la piste et
sont utiles pour comparer le volume relatif des pistes.L'intensité sonore est la qualité d'un son qui est la principale corrélat psychologique de la force physique (amplitude). Les valeurs varient généralement entre -60 et 0 dB.

#### a-Traitement


```{r}
# Histogramme loudness
ggplot(data, aes(x = loudness, fill = label)) +
  geom_histogram( alpha = 0.5, bins = 30)  +
  labs(title = "Histogramme loudness",
       x = "loudness", y = "Fréquence") +
  theme_minimal()
```



```{r}


# Définir les données
d <- data.frame(loudness_like = loudness_like, loudness_dislike = loudness_dislike)

# Spécifier le modèle JAGS

model_string_loudness <- "
model {
  # Number of successes
  for (i in 1:n){
    y1[i] ~ dnorm(mu1, sigma1)
  }
  for (i in 1:n){
    y2[i] ~ dnorm(mu2, sigma2)
  }

  mu1 ~ dunif(-40, 0)
  mu2 ~ dunif(-40, 0)
  
  sigma1 ~ dunif(0, 70)
  sigma2 ~ dunif(0, 70)
}
"


# Créer une liste de données pour JAGS
data_list <- list(y1 = d$loudness_like, y2 = d$loudness_dislike, n = nrow(d))

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1","mu2","sigma1", "sigma2"))

# Visualiser les résultats
plot_credible_intervals(jags_samples)

```

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
```

```{r}
# The probability that the rate theta1 is smaller than theta2
mean(s$mu2 < s$mu1)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$mu2 - s$mu1)
```
**Remarque** : Avec l'histogramme ci-contre et après calcul de la probabilité on peut donc constater que l'instructeur préfère les musique les pas très bruyantes.


#### b-Fake data check 

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n) {
  mu1_fake <- -20  # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- -15
  
  sigma1_fake <- 30
  sigma2_fake <- 40
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n,mu1_fake, sigma1_fake)
  y2_fake <- rnorm(n,mu2_fake, sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(loudness_like))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n = length(fake_data$y1_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```


**Conclusion** : je ne sais pas comment interpréter les sigmas



### 2- Variable Mode

**Description :** Mode indique la modalité (majeure ou mineure) d'un
piste, le type de gamme à partir de laquelle son contenu mélodique est
dérivé. Le majeur est représenté par 1 et le mineur par 0.

#### a-Traitement


```{r}
# Histogramme mode
ggplot(data, aes(x = mode, fill = label)) +
  geom_histogram( alpha = 0.5, bins = 30)  +
  labs(title = "Histogramme mode",
       x = "mode", y = "Fréquence") +
  theme_minimal()
```




```{r}
# Définir les données
d <- data.frame(mode_like = mode_like, mode_dislike = mode_dislike)

model_string_mode <- "
model {
  # Number of successes
  for (i in 1:n){
    y1[i] ~ dbern(theta1)
  }
  for (i in 1:n){
    y2[i] ~ dbern(theta2)
  }

  theta1 ~ dbeta(1, 1)
  theta2 ~ dbeta(1, 1)
}
"

# Créer une liste de données pour JAGS
data_list <- list(y1 = mode_like, y2 = mode_dislike, n = nrow(d))

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1", "theta2"))

# Visualiser les résultats
plot_credible_intervals(jags_samples)

```
```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
```



```{r}

# The probability that the rate theta1 is smaller than theta2
mean(s$theta1 < s$theta2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$theta2 - s$theta1)
```

**Remarque** : L'instructeur préfére davantage les musiques en mode 0 qu'en mode 1


#### b-Fake data check 


```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n) {
  theta1_fake <- 0.74  # Utiliser la médiane au lieu de la moyenne
  theta2_fake <- 0.5
  
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rbernoulli(n,theta1_fake)
  y2_fake <- rbernoulli(n,theta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(nrow(d))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n = nrow(d))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1", "theta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```




**Conclusion :**





### 3- Variable Speechiness

**Description :** Speechiness  détecte la présence de mots prononcés dans une piste.les valeurs supérieures à 0,66 décrivent des morceaux qui sont probablement entièrement constitués de paroles
mots. Les valeurs comprises entre 0,33 et 0,66 décrivent des pistes qui peut contenir à la fois de la musique et de la parole, soit en sections, soit en  couches, y compris des cas tels que la musique rap. Valeurs ci-dessous 0,33 représente très probablement la musique et d'autres éléments non vocaux.

#### a-Traitement

```{r}
# Histogramme speechiness
ggplot(data, aes(x = speechiness, fill = label)) +
  geom_histogram( alpha = 0.5, bins = 30)  +
  labs(title = "Histogramme speechiness",
       x = "speechiness", y = "Fréquence") +
  theme_minimal()
```



```{r}

# Définir les données
d <- data.frame(speechiness_like = speechiness_like, speechiness_dislike = speechiness_dislike)

# Spécifier le modèle JAGS
model_string_speechiness <- "
model {
  # Number of successes
  for (i in 1:n){
    y1[i] ~ dgamma(alpha1,beta1)
  }
  for (i in 1:n){
    y2[i] ~ dgamma(alpha2,beta2)
  }

  alpha1 ~ dgamma(2,0.8)
  alpha2 ~ dgamma(2,0.8)
  
  beta1 ~ dgamma(2,0.8)
  beta2 ~ dgamma(2,0.8)
}
"



# Créer une liste de données pour JAGS
data_list <- list(y1 = d$speechiness_like, y2 = d$speechiness_dislike, n = nrow(d))

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "alpha2","beta1","beta2"))

# Visualiser les résultats
plot_credible_intervals(jags_samples)

```



```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

```

```{r}
# The probability that the rate theta1 is smaller than theta2
mean(s$beta1 < s$beta2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$beta2 - s$beta1)
```

```{r}
# The probability that the rate theta1 is smaller than theta2
mean(s$alpha1 < s$alpha2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$alpha2 - s$alpha1)
```


**Remarque :** L'intructeur préfère les musiques avec le plus de paroles (les plus chantées) 

#### b-Fake data check 



```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n) {
  alpha1_fake <- 2  # Utiliser la médiane au lieu de la moyenne
  alpha2_fake <- 1.5
  
  beta1_fake <- 0.7
  beta2_fake <- 4 
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n,alpha1_fake, beta1_fake)
  y2_fake <- rnorm(n,alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(speechiness_like))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n = length(fake_data$y1_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "beta1","alpha2","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```



**Conclusion :**




## III- Regression


```{r}
library(rstan)
library(rstanarm)
set.seed(123)


# Créer une variable binaire (0 ou 1)
y <- data$label
y <- ifelse(data$label == "like", 1, 0)


# Spécifier le modèle de régression logistique
model <- stan_glm(y ~ danceability+energy+valence+speechiness, family = binomial(),data = data)

# Résumé du modèle
#summary(model)

# Afficher les diagnostics
plot(model)
```

## Check poour partie code claude


```{r}
plot_credible_intervals <- function(fit,title) {
  # Extract the MCMC samples and the names of the parameters
  samples <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
  params <- names(samples)

  # Calculate the 50% and 95% credible intervals for each parameter
  intervals <- data.frame(param = character(), lower = numeric(), upper = numeric())
  for (param in params) {
    est_mean = mean(samples[[param]])
    est_median = median(samples[[param]])
    ci_50_infCI <- quantile(samples[[param]], probs = 0.25)
    ci_50_supCI <- quantile(samples[[param]], probs = 0.75)
    ci_95_infCI <- quantile(samples[[param]], probs = 0.025)
    ci_95_supCI <- quantile(samples[[param]], probs = 0.975)
    intervals <- rbind(intervals, data.frame(param = param, est_mean = est_mean, est_median = est_median, ci_50_infCI = ci_50_infCI, ci_50_supCI = ci_50_supCI, ci_95_infCI = ci_95_infCI, ci_95_supCI = ci_95_supCI))
  }

  # Create a ggplot object
  p <- ggplot(intervals, aes(y = param)) +
    theme_classic() +
    geom_segment(aes(y = param, yend = param, x = ci_95_infCI, xend = ci_95_supCI),
                 color = "red", size = 0.5) +
    geom_segment(aes(y = param, yend = param, x = ci_50_infCI, xend = ci_50_supCI),
                 color = "red", size = 1.5) +
        geom_point(aes(x = est_mean), size = 3) +
    labs(title = paste(title)) + 
    xlab("")  + 
    ylab("")

  # Print the plot
  print(p)
}
```



```{r}
sample=rbind(subset(data, label == 1)[1:50,],subset(data, label == 0)[1:50,])

sample=sample[sample(length(1:nrow(sample))),]
```


```{r}

model_string_liv <- "
model {
  alpha1 ~ dunif(0,3);
  alpha2 ~ dunif(0,3);
  beta1 ~ dunif(10,20);
  beta2 ~ dunif(10,20);
  
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"

liked_liveness=sample[sample[,"label"]==1,"liveness"]
disliked_liveness=sample[sample[,"label"]==0,"liveness"]

data_list_liv <- list(y1 = liked_liveness,  y2 = disliked_liveness, 
                  n1 = length(liked_liveness), n2 = length(disliked_liveness))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list_liv, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples,"Posterior credible intervals for Liveness Model")
```