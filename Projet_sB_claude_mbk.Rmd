---
title: "Projet statistique bayésienne"
author: "Lyne nengueko"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Charger la librairie
library(runjags)
library(tidyverse)
library(rjags)
library(coda)
```

## I- Importation de la Dataset


```{r}
data=read.csv("spotify_preferences.csv")
summary(data)
```

```{r}
variables=data[1:13]
data$label <- as.factor(data$label)
```


## II-Visualisation des datas

```{r}
library(corrplot)
cor_variables=cor(variables)
corrplot(cor_variables)
```

```{r}
# Charger la librairie ggplot2
library(ggplot2)

# Liste des noms des variables à tracer
variables_a_tracer <- names(variables)[-5]  # Sélectionne les noms des colonnes commençant par "valeur"

for (variable in variables_a_tracer) {
    # Tracer les histogrammes
  print(variable)
  p=ggplot(data, aes(x = !!sym(variable), fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme des valeurs en fonction du label",
         x = variable,
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
  print(p)
}

```

## Check poour partie code claude


```{r}
plot_credible_intervals <- function(fit,title) {
  # Extract the MCMC samples and the names of the parameters
  samples <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
  params <- names(samples)

  # Calculate the 50% and 95% credible intervals for each parameter
  intervals <- data.frame(param = character(), lower = numeric(), upper = numeric())
  for (param in params) {
    est_mean = mean(samples[[param]])
    est_median = median(samples[[param]])
    ci_50_infCI <- quantile(samples[[param]], probs = 0.25)
    ci_50_supCI <- quantile(samples[[param]], probs = 0.75)
    ci_95_infCI <- quantile(samples[[param]], probs = 0.025)
    ci_95_supCI <- quantile(samples[[param]], probs = 0.975)
    intervals <- rbind(intervals, data.frame(param = param, est_mean = est_mean, est_median = est_median, ci_50_infCI = ci_50_infCI, ci_50_supCI = ci_50_supCI, ci_95_infCI = ci_95_infCI, ci_95_supCI = ci_95_supCI))
  }

  # Create a ggplot object
  p <- ggplot(intervals, aes(y = param)) +
    theme_classic() +
    geom_segment(aes(y = param, yend = param, x = ci_95_infCI, xend = ci_95_supCI),
                 color = "red", size = 0.5) +
    geom_segment(aes(y = param, yend = param, x = ci_50_infCI, xend = ci_50_supCI),
                 color = "red", size = 1.5) +
        geom_point(aes(x = est_mean), size = 3) +
    labs(title = paste(title)) + 
    xlab("")  + 
    ylab("")

  # Print the plot
  print(p)
}
```

# Préparation du dataset:

Nous devons maintenant préparer le dataset. Les datas sont plutôt clean donc le seul "travail que nous à faire dessus est le split des 100 datas avec lesquelles nous allons travailler pour établir le prior. 


```{r}
sample=rbind(subset(data, label == "like")[1:50,],subset(data, label == "dislike")[1:50,])

sample=sample[sample(length(1:nrow(sample))),]
```

# Etude des variables acousticness, instrumentalness,liveness. 

1) Etude d'acousticness

**description** A confidence measure from 0.0 to 1.0 of
whether the track is acoustic. 1.0 represents high
confidence the track is acoustic.

```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(sample, aes(x = acousticness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    stat_function(fun = beta_density, args = list(alpha = 0.7, beta = 0.7), color = "black") +
    labs(title = "Histogramme des valeurs en fonction du label",
         x = "Acousticness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label

```

En observant les datas, je suppose que l'accousticness des disliked suivent une beta, la distribution des likes comme cuvette applatie fit avec une loi beta où $\alpha=\beta\le 1$. 


```{r}
model_string_acc <- "
model {
  alpha1 ~ dunif(0,2);
  alpha2 ~ dunif(0,2);
  beta1 ~ dunif(0,2);
  beta2 ~ dunif(0,2);
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"

liked_acousticness=sample[sample[,"label"]==1,"acousticness"]
disliked_acousticness=sample[sample[,"label"]==0,"acousticness"]

data_list_acc <- list(y1 = liked_acousticness, y2 = disliked_acousticness,
                  n1 = length(liked_acousticness), n2 = length(disliked_acousticness))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list_acc, monitor = c("alpha1","alpha2", "beta1","beta2"))

plot_credible_intervals(jags_samples,"Posterior credible intervals for accousticness model")
```

2) Instrumentalness

**description** Predicts whether a track contains no
vocals. "Ooh" and "aah" sounds are treated as
instrumental in this context. Rap or spoken word tracks are
clearly "vocal". The closer the instrumentalness value is to
1.0, the greater likelihood the track contains no vocal
content. Values above 0.5 are intended to represent
instrumental tracks, but confidence is higher as the value
approaches 1.0.

```{r}
gamma_density <- function(x, alpha, beta) {
  dgamma(x, shape = alpha, rate = beta)
}

ggplot(sample, aes(x = instrumentalness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  stat_function(fun = gamma_density, args = list(alpha = 1.5, beta = 120), color = "black") + 
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Instrumentalness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```

En observant les données on va partir sur une distribution de poisson pour les deux variables.


```{r}
model_string_instr <- "
model {

  alpha1 ~ dunif(1,2);
  alpha2 ~ dunif(1,2);
  beta1 ~ dunif(100,150);
  beta2 ~ dunif(100,150);

  for (i in 1:n1) {
    y1[i] ~ dgamma(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dgamma(alpha2,beta2);
  }

}
"

liked_instrumentalness=sample[sample[,"label"]==1,"instrumentalness"]
disliked_instrumentalness=sample[sample[,"label"]==0,"instrumentalness"]

data_list_instr <- list(y1 = liked_instrumentalness, y2 = disliked_instrumentalness, 
                  n1 = length(liked_instrumentalness), n2 = length(disliked_instrumentalness))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list_instr, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Compiling and producing posterior samples from the model.
# jags_samples <- run.jags(model = model_string, data = data_list_instr, monitor = c("mu1","mu2", "sigma1","sigma2"))

# Plotting and summarizing the posterior distribution
# s_instr=as.data.frame(jags_samples_instr)
# L_diff=s_instr$lambda1-s_instr$lamda2
# hist(L_diff)
#jags_samples_instr
plot_credible_intervals(jags_samples,"Posterior credible intervals for Instrumentalness Model")

```

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```

3) Liveness

**description**Detects the presence of an audience in the
recording. Higher liveness values represent an increased
probability that the track was performed live. A value above
0.8 provides strong likelihood that the track is live.

```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(sample, aes(x = liveness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  stat_function(fun = beta_density, args = list(alpha = 2.5, beta = 15), color = "black") +  # Add gamma density curve
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Liveness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```
Observation, on en déduit une loi beta

```{r}

model_string_liv <- "
model {
  alpha1 ~ dunif(0,3);
  alpha2 ~ dunif(0,3);
  beta1 ~ dunif(10,20);
  beta2 ~ dunif(10,20);
  
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"

liked_liveness=sample[sample[,"label"]=="like","liveness"]
disliked_liveness=sample[sample[,"label"]=="dislike","liveness"]

data_list_liv <- list(y1 = liked_liveness,  y2 = disliked_liveness, 
                  n1 = length(liked_liveness), n2 = length(disliked_liveness))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list_liv, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples,"Posterior credible intervals for Liveness Model")
```


```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```

# Essaie Regression Stan

```{r}
library(rstanarm)
library(rstan)
install.packages("V8")
library(V8)
```

```{r}
set.seed(123)

danceability <- data$danceability
energy <- data$energy
valence <- data$valence
loudness <- data$loudness
speechiness <- data$speechiness
instrumentalness <- data$instrumentalness


# Créer une variable binaire (0 ou 1)
y <- data$label
y <- ifelse(data$label == "like", 1, 0)
# Créer un data frame avec les données
data2 <- data.frame(y = y, x1 = danceability,x2=energy,x3=valence,x4=loudness,x5=speechiness,x6=instrumentalness)


# Spécifier le modèle de régression logistique
model <- stan_glm(y ~ danceability+energy+valence+loudness+speechiness+instrumentalness, family = binomial(), data = data2)

# Résumé du modèle
summary(model)

# Afficher les diagnostics
plot(model)
```

# Fake data check

```{r}

## FAKE DATA CHECK 

generate_fake_data_beta <- function(n1, n2,alpha1_fake,alpha2_fake,beta1_fake,beta2_fake) {
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rbeta(n1, alpha1_fake, beta1_fake)
  y2_fake <- rbeta(n1, alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

generate_fake_data_gamma <- function(n1, n2,alpha1_fake,alpha2_fake,beta1_fake,beta2_fake) {
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rgamma(n1, alpha1_fake, beta1_fake)
  y2_fake <- rgamma(n1, alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

#Liveness###########################################################################################################

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data_beta(length(liked_liveness), length(disliked_liveness),2.5,1.2,12,19)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(liked_liveness)
summary(disliked_liveness)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples, "FDC of Liveness Model: (A1,A2,B1,B2)=(2.5,1.2,12,19)")
summary(jags_samples)

#Accousticness#####################################################################################################

fake_data <- generate_fake_data_beta(length(liked_acousticness), length(disliked_acousticness),0.5,0.9,0.5,0.7)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(liked_acousticness)
summary(disliked_acousticness)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples, "FDC of Accousticness Model: (A1,A2,B1,B2)=(0.5,0.9,0.5,0.7)")
summary(jags_samples)

#Instrumentalness#####################################################################################################

fake_data <- generate_fake_data_gamma(length(liked_instrumentalness), length(disliked_instrumentalness),1.1,1.8,120,140)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(liked_instrumentalness)
summary(disliked_acousticness)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples, "FDC of Instrumentalness Model: (A1,A2,B1,B2)=(1.1,1.8,120,140)")
summary(jags_samples)
```
