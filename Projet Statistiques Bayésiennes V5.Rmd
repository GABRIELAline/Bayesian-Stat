---
title: "Projet Statistiques Bayésiennes : Données Spotify"
author: "Aline GABRIEL, Alimatou TRAORE, Claude MBIMBIKI, Muriel MAJUM and Lyne NENGUEKO"
date: "2024-03-26"
output:
  html_document:
    toc: true
editor_options: 
  markdown: 
    wrap: 72
---

# Packages

```{r}
options(warn = -1)
library(readr)
library(ggplot2)
library(R2jags)
library(runjags)
library(coda)
library(tidyverse)
#library(ggridges)
#library(ggExtra)
library(dplyr)
library(rjags)
library(rstanarm) ## régression avec stan
#library(openintro)
#library(mosaic)
library(corrplot)

```

```{r, include=FALSE}
plot_credible_intervals <- function(fit) {
  # Extract the MCMC samples and the names of the parameters
  samples <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
  params <- names(samples)

  # Calculate the 50% and 95% credible intervals for each parameter
  intervals <- data.frame(param = character(), lower = numeric(), upper = numeric())
  for (param in params) {
    est_mean = mean(samples[[param]])
    est_median = median(samples[[param]])
    ci_50_infCI <- quantile(samples[[param]], probs = 0.25)
    ci_50_supCI <- quantile(samples[[param]], probs = 0.75)
    ci_95_infCI <- quantile(samples[[param]], probs = 0.025)
    ci_95_supCI <- quantile(samples[[param]], probs = 0.975)
    intervals <- rbind(intervals, data.frame(param = param, est_mean = est_mean, est_median = est_median, ci_50_infCI = ci_50_infCI, ci_50_supCI = ci_50_supCI, ci_95_infCI = ci_95_infCI, ci_95_supCI = ci_95_supCI))
  }

  # Create a ggplot object
  p <- ggplot(intervals, aes(y = param)) +
    theme_classic() +
    geom_segment(aes(y = param, yend = param, x = ci_95_infCI, xend = ci_95_supCI),
                 color = "red", size = 0.5) +
    geom_segment(aes(y = param, yend = param, x = ci_50_infCI, xend = ci_50_supCI),
                 color = "red", size = 1.5) +
        geom_point(aes(x = est_mean), size = 3) +
    labs(title = "Posterior credible intervals") + 
    xlab("")  + 
    ylab("")

  # Print the plot
  print(p)
}
```


# Exploration et traitement des variables

```{r}
spotify_preferences <- read_csv("spotify_preferences.csv")
```

```{r}
data<-spotify_preferences
data$label<-as.factor(data$label)
#data$mode<-as.factor(data$mode)
summary(as.data.frame(data))
```


## Histogrammes

```{r}

plots <- lapply(colnames(data)[-c(14,5)], function(i) {
  ggplot(data = data, aes_string(x = i, fill = "label")) +
    geom_histogram(position = "identity", alpha = 0.7) + 
    labs(title = paste("Histogramme de", i, "en fonction des labels"),
         x = i, y = "Fréquence") +
    scale_fill_manual(values = c("blue", "red")) +  # Couleurs des labels
    theme_minimal()
})

plots

ggplot(data = data, aes(x = mode, fill = label)) +
  geom_bar( position = "identity", alpha = 0.7) +
  labs(title = "Histogramme de time_signature en fonction des labels",
       x = "time_signature", y = "Fréquence") +
  scale_fill_manual(values = c("blue", "red")) +  # Couleurs des labels
  theme_minimal()

ggplot(data = data, aes(x = label, fill = label)) +
  geom_bar( position = "identity", alpha = 0.7) +
  labs(title = "Histogramme de time_signature en fonction des labels",
       x = "time_signature", y = "Fréquence") +
  scale_fill_manual(values = c("blue", "red")) +  # Couleurs des labels
  theme_minimal()

```



## Création de vecteurs pour l'étude Bayésienne

```{r}

danceability_like <- data$danceability[data$label == "like"]
danceability_dislike <- data$danceability[data$label == "dislike"]

energy_like <- data$energy[data$label == "like"]
energy_dislike <- data$energy[data$label == "dislike"]

key_like <- data$key[data$label == "like"]
key_dislike <- data$key[data$label == "dislike"]


loudness_like <- data$loudness[data$label == "like"]
loudness_dislike<- data$loudness[data$label == "dislike"]

mode_like <- data$mode[data$label == "like"]
mode_dislike <- data$mode[data$label == "dislike"]

speechiness_like <- data$speechiness[data$label == "like"]
speechiness_dislike <- data$speechiness[data$label == "dislike"]


acousticness_like=data$acousticness[data$label == "like"]
acousticness_dislike=data$acousticness[data$label == "dislike"]

instrumentalness_like=data$instrumentalness[data$label == "like"]
instrumentalness_dislike=data$instrumentalness[data$label == "dislike"]

liveness_like=data$liveness[data$label == "like"]
liveness_dislike=data$liveness[data$label == "dislike"]

valence_like <- data$valence[data$label == "like"]
valence_dislike <- data$valence[data$label == "dislike"]

tempo_like <-  data$tempo[ data$label == "like"]
tempo_dislike <-  data$tempo[ data$label == "dislike"]

duration_like <- data$duration[data$label == "like"]
duration_dislike <- data$duration[data$label == "dislike"]

time_signature_like <- data$time_signature[data$label == "like"]
time_signature_dislike <- data$time_signature[data$label == "dislike"]
```

## Etude de corrélation

```{r}
correlation_matrix <- cor(data[,-c(5,14)])
corrplot(correlation_matrix, method = "circle")

```


# 1- Variable : danceability


### Modèle

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, sigma1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, sigma2)
  }

  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 1)
  sigma2 ~ dunif(0, 1)
}
"
y1 <- danceability_like
y2 <- danceability_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("mu1", "mu2", "sigma1", "sigma2"))

jags_samples
```


### Interprétation

```{r}
plot_credible_intervals(jags_samples)
```


```{r}

jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1    

hist(mu_diff, main = "Histogramme de mu2 - mu1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)

```

### Etude des mcmc

### Fake data check


**Conclusion** : 

# 2- Variable : energy

**Description :** 

### Modèle

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, sigma1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, sigma2)
  }

  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 1)
  sigma2 ~ dunif(0, 1)
}
"
y1 <- energy_like
y2 <- energy_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("mu1", "mu2", "sigma1", "sigma2"))

jags_samples
```

```{r}
plot_credible_intervals(jags_samples)
```

```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1    

hist(mu_diff, main = "Histogramme de mu2 - mu1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)
```

# 3- Variable : key

**Description :** 


### Modèle

```{r}
model_string <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dpois(lambda1)
  }
  for (i in 1:n2){
    y2[i] ~ dpois(lambda2)
  }

  lambda1 ~ dunif(1, 4)
  lambda2 ~ dunif(1, 6)
}
"
y1 <- key_like
y2 <- key_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))

jags_samples <- run.jags(model = model_string, data = data_list, monitor = c("lambda1", "lambda2"))

jags_samples
```


```{r}
plot_credible_intervals(jags_samples)
```

### Interprétation

```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mu_diff <- jags_samples_df$lambda2 - jags_samples_df$lambda1    

hist(mu_diff, main = "Histogramme de lambda2 - lambda1", xlab = "Différence entre mu1 et mu2")
mean(mu_diff > 0)
```


### Fake data check


**Conclusion** : 

# 4- Variable : loudness

**Description :** Les valeurs d'intensité sonore sont moyennées sur
l'ensemble de la piste et sont utiles pour comparer le volume relatif
des pistes.L'intensité sonore est la qualité d'un son qui est la
principale corrélat psychologique de la force physique (amplitude). Les
valeurs varient généralement entre -60 et 0 dB.


## Modèle 

```{r}
model_string_loudness <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dnorm(mu1, sigma1)
  }
  for (i in 1:n2){
    y2[i] ~ dnorm(mu2, sigma2)
  }

  mu1 ~ dunif(-40, 0)
  mu2 ~ dunif(-40, 0)
  
  sigma1 ~ dunif(0, 70)
  sigma2 ~ dunif(0, 70)
}
"


y1 = loudness_like
y2 = loudness_dislike
# Créer une liste de données pour JAGS
data_list <- list(y1 = y1, y2 = y2 ,n1 = length(y1), n2 = length(y2))

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Visualiser les résultats
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
# The probability that the rate theta1 is smaller than theta2
mean(s$mu2 < s$mu1)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$mu2 - s$mu1)
```

**Remarque** : Avec l'histogramme ci-contre et après calcul de la
probabilité on peut donc constater que l'instructeur préfère les
musiques pas très bruyantes.

## MCMC

```{r}
plot(jags_samples)
```

## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  mu1_fake <- -20  # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- -15
  
  sigma1_fake <- 30
  sigma2_fake <- 40
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1,mu1_fake, sigma1_fake)
  y2_fake <- rnorm(n2,mu2_fake, sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(loudness_like),length(loudness_dislike))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake),n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_loudness, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion** : Le modèle choisi est bien confirmé.

# 5- Variable : mode

**Description :** Mode indique la modalité (majeure ou mineure) d'un
piste, le type de gamme à partir de laquelle son contenu mélodique est
dérivé. Le majeur est représenté par 1 et le mineur par 0.

## Modèle

```{r}
model_string_mode <- "
model {
  theta1 ~ dbeta(1, 1)
  theta2 ~ dbeta(1, 1)
  
  for (i in 1:n1){
    y1[i] ~ dbern(theta1)
  }
  for (i in 1:n2){
    y2[i] ~ dbern(theta2)
  }
}
"


y1 = as.double(mode_like)
y2 = as.double(mode_dislike)

data_list <- list(y1 = y1, y2 = y2, n1=length(y1),n2=length(y2))

jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1","theta2"))
```

```{r}
plot_credible_intervals(jags_samples)
```



## Interprétation

## Etude des mcmc

```{r}
plot(jags_samples)
```


## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  theta1_fake <- 0.74  # Utiliser la médiane au lieu de la moyenne
  theta2_fake <- 0.5
  
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rbernoulli(n1,theta1_fake)
  y2_fake <- rbernoulli(n2,theta2_fake)
  
  return(list(y1_fake = as.double(y1_fake), y2_fake =as.double(y2_fake)))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(mode_like),length(mode_dislike))

# # Comparer les données factices avec les données réelles
# summary(fake_data$y1_fake)
# summary(fake_data$y2_fake)
# summary(y1)
# summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1=length(y1),n2=length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_mode, data = data_list, monitor = c("theta1", "theta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion :** Avec le plot suivant, les données fausses confirment bien notres modèle

# 6- Variable : speechiness

**Description :** Speechiness détecte la présence de mots prononcés dans
une piste.les valeurs supérieures à 0,66 décrivent des morceaux qui sont
probablement entièrement constitués de paroles mots. Les valeurs
comprises entre 0,33 et 0,66 décrivent des pistes qui peut contenir à la
fois de la musique et de la parole, soit en sections, soit en couches, y
compris des cas tels que la musique rap. Valeurs ci-dessous 0,33
représente très probablement la musique et d'autres éléments non vocaux.

## Modèle

```{r}
# Spécifier le modèle JAGS
model_string_speechiness <- "
model {
  # Number of successes
  for (i in 1:n1){
    y1[i] ~ dgamma(alpha1,beta1)
  }
  for (i in 1:n2){
    y2[i] ~ dgamma(alpha2,beta2)
  }

  alpha1 ~ dgamma(2,0.8)
  alpha2 ~ dgamma(2,0.8)
  
  beta1 ~ dgamma(2,0.8)
  beta2 ~ dgamma(2,0.8)
}
"
y1=speechiness_like
y2=speechiness_dislike
  
# Créer une liste de données pour JAGS
data_list <- list(y1 = y1, y2 = y2,n1 = length(y1), n2 = length(y2) )

# Exécuter le modèle et extraire les échantillons postérieurs
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "alpha2","beta1","beta2"))

# Visualiser les résultats
plot_credible_intervals(jags_samples)

```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

# The probability that the rate theta1 is smaller than theta2
mean(s$beta1 < s$beta2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$beta2 - s$beta1)
# The probability that the rate theta1 is smaller than theta2
mean(s$alpha1 < s$alpha2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$alpha2 - s$alpha1)
```

**Remarque :** L'intructeur préfère les musiques avec le plus de paroles
(les plus chantées)


## Etude des mcmc

```{r}
plot(jags_samples)
```

## Fake data check

```{r}
## FAKE DATA CHECK 

generate_fake_data <- function(n1,n2) {
  alpha1_fake <- 2  # Utiliser la médiane au lieu de la moyenne
  alpha2_fake <- 1.5
  
  beta1_fake <- 10
  beta2_fake <- 40
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rgamma(n1,alpha1_fake, beta1_fake)
  y2_fake <- rgamma(n2,alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(speechiness_like),length(speechiness_dislike))

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(y1), n2 = length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_speechiness, data = data_list, monitor = c("alpha1", "alpha2","beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```

**Conclusion :** Le beta2 trouvé par le modèle ne correspond tout a fait à celui considéré au départ lors de la simulation. Ce qui remet en cause l'exactitude du modèle.

# 7- Variable : acousticness

**description** A confidence measure from 0.0 to 1.0 of whether the
track is acoustic. 1.0 represents high confidence the track is acoustic.

En observant les datas, je suppose que l'accousticness des disliked
suivent une beta, la distribution des likes comme cuvette applatie fit
avec une loi beta où $\alpha=\beta\le 1$.



```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(data, aes(x = acousticness, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    stat_function(fun = beta_density, args = list(alpha = 0.7, beta = 0.7), color = "black") +
    labs(title = "Histogramme des valeurs en fonction du label",
         x = "Acousticness",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label

```

## Modèle

```{r}
model_string_acc <- "
model {
  alpha1 ~ dunif(0,2);
  alpha2 ~ dunif(0,2);
  beta1 ~ dunif(0,2);
  beta2 ~ dunif(0,2);
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"


data_list_acc <- list(y1 = acousticness_like, y2 = acousticness_dislike,
                  n1 = length(y1), n2 = length(y2))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list_acc, monitor = c("alpha1","alpha2", "beta1","beta2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

## Etude des mcmc


## Fake data check

```{r}
generate_fake_data_beta <- function(n1, n2,alpha1_fake,alpha2_fake,beta1_fake,beta2_fake) {

  y1_fake <- rbeta(n1, alpha1_fake, beta1_fake)
  y2_fake <- rbeta(n1, alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

generate_fake_data_gamma <- function(n1, n2,alpha1_fake,alpha2_fake,beta1_fake,beta2_fake) {
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rgamma(n1, alpha1_fake, beta1_fake)
  y2_fake <- rgamma(n1, alpha2_fake, beta2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}
```


```{r}
fake_data <- generate_fake_data_beta(length(acousticness_like), length(acousticness_dislike),0.5,0.9,0.5,0.7)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(acousticness_like)
summary(acousticness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_acc, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)

```



**Conclusion** : 


# 8- Variable : instrumentalness

**description** Predicts whether a track contains no vocals. "Ooh" and
"aah" sounds are treated as instrumental in this context. Rap or spoken
word tracks are clearly "vocal". The closer the instrumentalness value
is to 1.0, the greater likelihood the track contains no vocal content.
Values above 0.5 are intended to represent instrumental tracks, but
confidence is higher as the value approaches 1.0.


```{r}
gamma_density <- function(x, alpha, beta) {
  dgamma(x, shape = alpha, rate = beta)
}

ggplot(data, aes(x = instrumentalness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  stat_function(fun = beta_density, args = list(1.3,120), color = "red") +# Add gamma density curve
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Instrumentalness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```

En observant les données on va partir sur une distribution de poisson
pour les deux variables.

## Modèle

```{r}
model_string_instr <- "
model {

  for (i in 1:n1){
    y1[i] ~ dgamma(alpha1,beta1)
  }
  for (i in 1:n2){
    y2[i] ~ dgamma(alpha2,beta2)
  }
  alpha1 ~ dunif(1,2);
  alpha2 ~ dunif(1,2);
  beta1 ~ dunif(100,150);
  beta2 ~ dunif(100,150);
}
"


y1 = instrumentalness_like+0.01
y2 = instrumentalness_dislike+0.01
data_list_instr <- list(y1 = y1, y2 = y2,n1 = length(y1), n2 =length(y2))
```


```{r}
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list_instr, monitor = c("alpha1","alpha2","beta1","beta2"))

```



```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```
## Etude des mcmc


## Fake data check


```{r}
fake_data <- generate_fake_data_gamma(length(instrumentalness_like), length(instrumentalness_dislike),1.1,1.8,120,140)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(instrumentalness_like)
summary(instrumentalness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_instr, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)
```




**Conclusion** : 

# 9- Variable : liveness

**description**Detects the presence of an audience in the
recording. Higher liveness values represent an increased
probability that the track was performed live. A value above
0.8 provides strong likelihood that the track is live.


```{r}
beta_density <- function(x, alpha, beta) {
  dbeta(x, shape1 = alpha, shape2 = beta)
}

ggplot(data, aes(x = liveness, fill = label)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
  stat_function(fun = beta_density, args = list(alpha = 2.5, beta = 15), color = "black") +  # Add gamma density curve
  labs(title = "Histogramme des valeurs en fonction du label",
       x = "Liveness",
       y = "Fréquence") +
  scale_fill_manual(values = c("red", "blue"))  # Définir les couleurs pour chaque label
```
Observation, on en déduit une loi beta

## Modèle

```{r}

model_string_liv <- "
model {
  alpha1 ~ dunif(0,3);
  alpha2 ~ dunif(0,3);
  beta1 ~ dunif(10,20);
  beta2 ~ dunif(10,20);
  
  for (i in 1:n1) {
    y1[i] ~ dbeta(alpha1,beta1);
  }

  for (i in 1:n2) {
    y2[i] ~ dbeta(alpha2,beta2);
  }
}
"


data_list_liv <- list(y1 = liveness_like,  y2 = liveness_dislike, 
                  n1 = length(liveness_like), n2 = length(liveness_dislike))

# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list_liv, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())

diff_alpha=s$alpha1 - s$alpha2
diff_beta=s$beta1 - s$beta2

mean_alpha=mean(s$alpha1 < s$alpha2)
mean_beta=mean(s$beta1 < s$beta2)

hist(diff_alpha)
hist(diff_beta)
```


## Etude des mcmc


## Fake data check



```{r}
#Liveness##

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data_beta(length(liveness_like), length(liveness_dislike),2.5,1.2,12,19)

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(liveness_like)
summary(liveness_dislike)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_liv, data = data_list, monitor = c("alpha1","alpha2", "beta1","beta2"))

# Plotting and summarizing the posterior distribution
jags_samples
```


```{r}
plot_credible_intervals(jags_samples)
summary(jags_samples)
```

**Conclusion** : 

# 10- Variable : valence

**Description :** 

## Modèles

```{r message=FALSE, warning=FALSE}
model_string_valence <- "
model {
  mu1 ~ dunif(0, 1)
  mu2 ~ dunif(0, 1)
  sigma1 ~ dunif(0, 1)
  sigma2 ~ dunif(0, 1)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- valence_like
y2 <- valence_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_valence, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
jags_samples
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

mean(jags_samples_df$mu1 < jags_samples_df$mu2)

hist(jags_samples_df$mu1 - jags_samples_df$mu2)
```

## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```

## Fake data check

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 0.5  # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 0.5
  
  sigma1_fake<-0.1
  sigma2_fake<-0.1
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(valence_like), length(valence_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_valence, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Plotting and summarizing the posterior distribution
plot_credible_intervals(jags_samples)
summary(jags_samples)
```

**Conclusion** : 

## Interprétation

# 11- Variable : tempo

**Description :** 

## Modèle

```{r message=FALSE, warning=FALSE}


model_string_tempo <- "
model {
  mu1 ~ dunif(0, 2000)
  mu2 ~ dunif(0, 2000)
  sigma1 ~ dunif(0, 1000)
  sigma2 ~ dunif(0, 1000)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- tempo_like
y2 <- tempo_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_tempo, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

## Interprétation

```{r}
s <- as.data.frame(jags_samples$mcmc %>% lapply(as_tibble) %>% bind_rows())
head(s)
 # The probability that the rate theta1 is smaller than theta2
mean(s$mu1 < s$mu2)
# The above is a short cut for sum(s$theta1 < s$theta2) / nrow(s)

# Plotting distribution of the difference between theta1 and theta2
hist(s$mu1 - s$mu2)
```

## Etude des mcmc

```{r}
plot(jags_samples)

gelman.diag(jags_samples)

autocorr.plot(jags_samples)
```


## Fake data

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 100 # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 129
  
  sigma1_fake<-20
  sigma2_fake<-10
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(valence_like), length(valence_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_tempo, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
plot_credible_intervals(jags_samples)
```

**Conclusion** : 

# 12- Variable : duration

**Description :** 

```{r}
ggplot(data, aes(x = duration, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de duration en fonction du label",
         x = "duration",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```


## Modèles

```{r}
model_string_duration <- "
model {
  mu1 ~ dunif(180000, 240000)
  mu2 ~ dunif(180000, 240000)
  sigma1 ~ dunif(0, 100000)
  sigma2 ~ dunif(0, 100000)
  
  for (i in 1:n1) {
    y1[i] ~ dnorm(mu1, precision1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dnorm(mu2, precision2)
  }
  
  precision1 <- 1 / (sigma1 * sigma1)
  precision2 <- 1 / (sigma2 * sigma2)
}
"

# Définition des données
y1 <- duration_like
y2 <- duration_dislike
data_list_duration <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))
# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_duration, data = data_list_duration, monitor = c("mu1", "mu2","sigma1","sigma2"))
```

```{r}
# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```

**Trace plots** : Les graphiques de trace montrent l'évolution des
chaînes de Markov générées par l'échantillonnage de Monte Carlo par
chaîne de Markov (MCMC) pour chaque paramètre du modèle. Ils permettent
de vérifier la convergence des chaînes en examinant si elles semblent se
stabiliser autour d'une valeur ou si elles continuent à errer. Une
convergence satisfaisante est indiquée par des trajectoires qui se
chevauchent et restent stationnaires après un certain nombre
d'itérations.

**Statistique Gelman-Rubin** : Cette statistique est utilisée pour
évaluer la convergence des chaînes MCMC en comparant la variance
intra-chaîne avec la variance inter-chaîne. Une valeur proche de 1 (par
exemple, inférieure à 1,1) indique une convergence satisfaisante. Des
valeurs significativement plus élevées suggèrent que les chaînes n'ont
pas convergé.

**Graphiques d'autocorrélation** : Ces graphiques montrent
l'autocorrélation des échantillons de chaînes MCMC à différentes
retards. Ils permettent d'évaluer la dépendance entre les échantillons
successifs. Des autocorrélations élevées à des retards élevés peuvent
indiquer une mauvaise efficacité d'échantillonnage. Idéalement, on
cherche à minimiser l'autocorrélation pour obtenir des échantillons
indépendants.

Taille effective de l'échantillon : C'est une mesure de l'efficacité
d'échantillonnage des chaînes MCMC. Étant donné que les échantillons ne
sont pas indépendants en raison de l'autocorrélation, la taille
effective de l'échantillon est généralement inférieure à la taille
réelle de l'échantillon. Elle est calculée en prenant en compte
l'autocorrélation entre les échantillons. Une taille effective plus
élevée indique une meilleure efficacité d'échantillonnage.

En résumé, ces diagnostics sont utilisés pour évaluer la convergence et
la qualité des échantillons générés par les méthodes MCMC. Une fois que
les chaînes sont convergentes et que les échantillons sont jugés
suffisamment indépendants et efficaces, on peut utiliser ces
échantillons pour estimer les quantités d'intérêt et effectuer des
inférences sur le modèle bayésien ajusté.


## Interprétation

```{r}
# Conversion des échantillons JAGS en un data frame
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

# Calcul de la différence entre mu2 et mu1
mu_diff <- jags_samples_df$mu2 - jags_samples_df$mu1



# Tracé de l'histogramme
hist(mu_diff)

```

```{r}
mean(mu_diff < 0)
```

## Etude des mcmc

```{r}
# Vérification de la convergence de l'algorithme MCMC
print(jags_samples)

# Tracer les diagnostics de convergence
plot(jags_samples)
```

```{r}

# Trace plots
plot(jags_samples)

# Gelman-Rubin statistic
gelman.diag(jags_samples)

# Autocorrelation plots
autocorr.plot(jags_samples)

# Effective sample size
effectiveSize(jags_samples)

```

## Fake data check

```{r message=FALSE, warning=FALSE}
generate_fake_data <- function(n1, n2) {
  mu1_fake <- 200000 # Utiliser la médiane au lieu de la moyenne
  mu2_fake <- 230000
  
  sigma1_fake<-40000
  sigma2_fake<-60000
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rnorm(n1, mu1_fake,sigma1_fake)
  y2_fake <- rnorm(n2, mu2_fake,sigma2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(duration_like), length(duration_dislike))


data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_duration, data = data_list, monitor = c("mu1", "mu2","sigma1","sigma2"))
```
```{r}
plot_credible_intervals(jags_samples)
```
**Conclusion** : 


# 13- Variable : time_signature

```{r}
ggplot(data, aes(x = time_signature, fill = label)) +
    geom_histogram(alpha = 0.5, position = "identity", bins = 30) +
    labs(title = "Histogramme de time_signature en fonction du label",
         x = "time_signature",
         y = "Fréquence") +
    scale_fill_manual(values = c("red", "blue")) 
```


**Description :** 


## Modèle

```{r}
model_string_time_signature_like <- "
model {
  lambda1 ~ dgamma(4*12, 12)
  lambda2 ~ dgamma(4*12, 12)
  
  
  for (i in 1:n1) {
    y1[i] ~ dpois(lambda1)
  }
  
  for (i in 1:n2) {
    y2[i] ~ dpois(lambda2)
  }
}
"


# Définition des données
y1 <- time_signature_like
y2 <- time_signature_dislike
data_list <- list(y1 = y1, y2 = y2, n1 = length(y1), n2 = length(y2))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_time_signature_like, data = data_list, monitor = c("lambda1", "lambda2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
```


## Interprétation

```{r}
# Conversion des échantillons JAGS en un data frame
jags_samples_df <- as.data.frame(as.mcmc(jags_samples))

# Calcul de la différence entre mu2 et mu1
lambda_diff <- jags_samples_df$lambda2 - jags_samples_df$lambda1

# Tracé de l'histogramme
hist(lambda_diff)

mean(lambda_diff > 0)
```

## Etude des mcmc

```{r}
# Installer et charger les packages nécessaires
#install.packages("coda")
library(coda)

# Trace plots
plot(jags_samples)

# Gelman-Rubin statistic
gelman.diag(jags_samples)

# Autocorrelation plots
autocorr.plot(jags_samples)

# Effective sample size
effectiveSize(jags_samples)
```

## Fake data check

```{r}
generate_fake_data <- function(n1, n2) {
  lambda1_fake <- 4  # Utiliser la médiane au lieu de la moyenne
  lambda2_fake <- 5
  
  # Générer des données factices à partir de la distribution de Poisson
  y1_fake <- rpois(n1, lambda1_fake)
  y2_fake <- rpois(n2, lambda2_fake)
  
  return(list(y1_fake = y1_fake, y2_fake = y2_fake))
}

# Générer des données factices à partir des échantillons postérieurs
fake_data <- generate_fake_data(length(time_signature_like), length(time_signature_dislike))

# Comparer les données factices avec les données réelles
summary(fake_data$y1_fake)
summary(fake_data$y2_fake)
summary(y1)
summary(y2)

data_list <- list(y1 = fake_data$y1_fake, y2 = fake_data$y2_fake, n1 = length(fake_data$y1_fake), n2 = length(fake_data$y2_fake))


# Compiling and producing posterior samples from the model.
jags_samples <- run.jags(model = model_string_time_signature_like, data = data_list, monitor = c("lambda1", "lambda2"))

# Plotting and summarizing the posterior distribution
jags_samples
plot_credible_intervals(jags_samples)
summary(jags_samples)
```




# Regression stan_glm

```{r}
colnames(data)
```

```{r}
set.seed(123)

# Créer une variable binaire (0 ou 1)
label <- spotify_preferences$label
label <- ifelse(spotify_preferences$label == "like", 1, 0)

# Spécifier le modèle de régression logistique
model <- stan_glm(label ~ danceability + energy +key+  loudness + speechiness + acousticness + instrumentalness + liveness + valence + tempo + duration + time_signature, family = binomial(), data = data)

# Résumé du modèle
summary(model)

# Afficher les diagnostics
plot(model)
```



# Prédiction

```{r}
# Charger la librairie nécessaire
#library(caret)

# Faire des prédictions sur les données d'entraînement
predictions <- predict(model, type = "response")

# Seuiller les prédictions à 0 ou 1
threshold <- 0.5
predictions_binary <- ifelse(predictions > threshold, 1, 0)

# Convertir en un vecteur de 0 et 1
datalabel_binary <- ifelse(data$label == "like", 1, 0)

# Calculer l'exactitude
accuracy <- mean(predictions_binary == datalabel_binary)
accuracy
```

Stevie Wonder	At The Close Of A Century	I Just Called To Say I Love You



```{r}
X_new=data.frame(danceability=0.748,energy=0.551,key=1,loudness=-9.054,mode=1,speechiness=0.0239, acousticness=0.243, instrumentalness=1.57e-06, liveness=0.0943, valence= 0.65, tempo=113.535, duration =262240 ,time_signature=4)
```

Ed Sheeran	÷ (Deluxe)	Perfect

```{r}
X_new=data.frame(danceability=0.599,energy=0.448,key=8,loudness=-6.312,mode=1,speechiness=0.0232, acousticness=0.163, instrumentalness=0.0, liveness=0.106, valence= 0.168, tempo=95.05, duration =263400 ,time_signature=3)
# Faire des prédictions sur de nouvelles données
predictions <- predict(model, newdata = X_new, type = "response")

threshold <- 0.5
predictions_ <- ifelse(predictions > threshold, "like", "dislike")
predictions_
```

